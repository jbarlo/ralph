#!/usr/bin/env bash
set -e

SCRIPT_PATH="${BASH_SOURCE[0]}"
# Resolve symlinks to get the actual script location
while [ -L "$SCRIPT_PATH" ]; do
  SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
  SCRIPT_PATH="$(readlink "$SCRIPT_PATH")"
  # Handle relative symlinks
  [[ "$SCRIPT_PATH" != /* ]] && SCRIPT_PATH="$SCRIPT_DIR/$SCRIPT_PATH"
done
RALPH_DIR="$(cd "$(dirname "$SCRIPT_PATH")/.." && pwd)"

# Dispatch subcommands
case "${1:-}" in
  migrate)
    exec "$RALPH_DIR/bin/ralph-migrate"
    ;;
  hooks)
    shift
    exec "$RALPH_DIR/bin/ralph-hooks" "$@"
    ;;
esac

MAX_ITER="${1:-20}"

source "$RALPH_DIR/lib/ralph-state.sh"

# Check we're in a git repo
if ! git rev-parse --is-inside-work-tree &>/dev/null; then
  echo "Error: ralph must run inside a git repository"
  exit 1
fi

# Resolve host git config path
GITCONFIG=""
if [[ -f ~/.gitconfig ]]; then
  GITCONFIG="$HOME/.gitconfig"
elif [[ -f ~/.config/git/config ]]; then
  GITCONFIG="$HOME/.config/git/config"
fi

# TTY detection: use -it if interactive, -i otherwise
DOCKER_FLAGS="-i"
if [ -t 0 ]; then
  DOCKER_FLAGS="-it"
fi

# Pre-flight: verify claude auth works
echo "Verifying claude auth..."
if ! docker run --rm --userns=host $DOCKER_FLAGS \
  -v ~/.claude:/claude-host:ro \
  ralph claude --version &>/dev/null; then
  echo "Error: claude auth check failed. Check your credentials."
  exit 1
fi
echo "Auth OK. Starting ralph loop (max $MAX_ITER iterations)..."

# Host-side iteration loop
for i in $(seq 1 $MAX_ITER); do
  echo ""
  echo "=== Iteration $i/$MAX_ITER ==="

  # Check if all tickets done (no pending or in_progress)
  if jq -e '[.tickets[] | select(.status == "pending" or .status == "in_progress")] | length == 0' "$RALPH_TICKETS" > /dev/null 2>&1; then
    echo "All tickets complete!"
    exit 0
  fi

  # Show remaining tickets
  REMAINING=$(jq '[.tickets[] | select(.status == "pending" or .status == "in_progress")] | length' "$RALPH_TICKETS")
  echo "Remaining tickets: $REMAINING"

  # Run on-start hook (on host) with current ticket context
  if [[ -d "$RALPH_HOOKS_DIR/on-start" ]]; then
    CURRENT_TICKET=$(jq -c '[.tickets[] | select(.status == "pending" or .status == "in_progress")] | sort_by(.priority) | first' "$RALPH_TICKETS" 2>/dev/null || echo '{}')
    if [[ -z "$CURRENT_TICKET" || "$CURRENT_TICKET" == "null" ]]; then
      CURRENT_TICKET='{}'
    fi
    TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    PAYLOAD_FILE=$(mktemp)
    jq --arg ts "$TIMESTAMP" \
      '{event: "start", ticket: ([.tickets[] | select(.status == "pending" or .status == "in_progress")] | sort_by(.priority) | first), timestamp: $ts}' "$RALPH_TICKETS" > "$PAYLOAD_FILE"
    "$RALPH_DIR/bin/ralph-hooks" on-start "$PAYLOAD_FILE" || true
    rm -f "$PAYLOAD_FILE"
  fi

  # Clean up any exited ralph container
  if docker ps -a --filter "status=exited" --format '{{.Names}}' | grep -q '^ralph$'; then
    docker rm ralph >/dev/null
  fi

  # Check for running container
  if docker ps --format '{{.Names}}' | grep -q '^ralph$'; then
    echo "Error: Container 'ralph' is already running. Run 'ralph-stop' to stop it."
    exit 1
  fi

  # Capture ticket state before docker run for comparison
  TICKET_BEFORE=$(jq -c '[.tickets[] | select(.status == "pending" or .status == "in_progress")] | sort_by(.priority) | first' "$RALPH_TICKETS" 2>/dev/null || echo '{}')
  if [[ -z "$TICKET_BEFORE" || "$TICKET_BEFORE" == "null" ]]; then
    TICKET_BEFORE='{}'
  fi
  TICKET_ID_BEFORE=$(echo "$TICKET_BEFORE" | jq -r '.id // empty')

  # Run docker for ONE ticket and capture exit code
  set +e
  docker run --name ralph --userns=host $DOCKER_FLAGS \
    -e RALPH_LOOP=1 \
    -v "$(pwd)":/workspace \
    -v "$(pwd)/RALPH.md":/workspace/CLAUDE.md:ro \
    -v ~/.claude:/claude-host:ro \
    ${GITCONFIG:+-v "$GITCONFIG":/home/ralph/.gitconfig-host:ro -e GIT_CONFIG_SYSTEM=/home/ralph/.gitconfig-host} \
    -v "$RALPH_DIR/prompt.md":/ralph/prompt.md:ro \
    ralph /ralph/ralph-once.sh
  DOCKER_EXIT=$?
  set -e

  # Re-resolve state paths (container may have migrated)
  ralph_resolve_state

  # Determine whether to run on-complete or on-error hook
  TICKET_AFTER=""
  TICKET_STATUS=""
  if [[ -n "$TICKET_ID_BEFORE" ]]; then
    TICKET_AFTER=$(jq -c --arg id "$TICKET_ID_BEFORE" '.tickets[] | select(.id == ($id | tonumber))' "$RALPH_TICKETS" 2>/dev/null || echo '{}')
    TICKET_STATUS=$(echo "$TICKET_AFTER" | jq -r '.status // empty')
  fi

  # Get current commit hash for hook context
  COMMIT_HASH=$(git rev-parse HEAD 2>/dev/null || echo "")

  # Run on-complete hook if docker exited successfully and ticket was completed
  if [[ $DOCKER_EXIT -eq 0 && -d "$RALPH_HOOKS_DIR/on-complete" && "$TICKET_STATUS" == "completed" ]]; then
    SUMMARY=""
    if [[ -f "$RALPH_PROGRESS" ]]; then
      SUMMARY=$(awk '/^## Ticket #/{found=1; buf=""} found{buf=buf"\n"$0} END{print buf}' "$RALPH_PROGRESS" | tail -c 2000)
    fi

    TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    PAYLOAD_FILE=$(mktemp)
    jq --arg id "$TICKET_ID_BEFORE" --arg summary "$SUMMARY" --arg ts "$TIMESTAMP" --arg commit "$COMMIT_HASH" \
      '{event: "complete", ticket: first(.tickets[] | select(.id == ($id | tonumber))), summary: $summary, timestamp: $ts, commit: $commit}' "$RALPH_TICKETS" > "$PAYLOAD_FILE"
    "$RALPH_DIR/bin/ralph-hooks" on-complete "$PAYLOAD_FILE" || true
    rm -f "$PAYLOAD_FILE"

  # Run on-error hook if docker exited non-zero or ticket completion not detected
  elif [[ -d "$RALPH_HOOKS_DIR/on-error" && -n "$TICKET_ID_BEFORE" ]]; then
    TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    PAYLOAD_FILE=$(mktemp)
    jq --arg id "$TICKET_ID_BEFORE" --argjson exit_code "$DOCKER_EXIT" --arg ts "$TIMESTAMP" --arg commit "$COMMIT_HASH" \
      '{event: "error", ticket: first(.tickets[] | select(.id == ($id | tonumber))), exit_code: $exit_code, timestamp: $ts, commit: $commit}' "$RALPH_TICKETS" > "$PAYLOAD_FILE"
    "$RALPH_DIR/bin/ralph-hooks" on-error "$PAYLOAD_FILE" || true
    rm -f "$PAYLOAD_FILE"

  fi
done

echo ""
echo "=== Max iterations ($MAX_ITER) reached ==="
echo "Some tickets may still be incomplete."
